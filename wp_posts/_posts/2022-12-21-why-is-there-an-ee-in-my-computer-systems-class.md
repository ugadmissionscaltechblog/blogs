---
title: Why is there an EE in my computer systems class?
image: /wp-content/uploads/images/2022/chase/516_20221222_000450_chrome.png
date: 2022-12-22
categories: 7847
author: Chase Blanchette
---
_Note: I’ll hyperlink some of the concepts I think are cool in this article, but generally, the topics I mention from classes should not be too difficult to research with some googling. I definitely encourage you to learn about these things on your own if they look interesting to you!_

In my first year at Caltech, I remember worrying a lot that whatever option I chose would end up dictating all of my classes and electives, and I’d never get the chance to explore my other interests. I ended up choosing electrical engineering (EE), but I never lost my interests in computer science (CS) and mechanical engineering (ME), particularly in the field of robotics.

Fortunately, I ended up having a fair bit of room to take electives that interested me – in some cases, interesting classes have been cross-listed as EE courses (even when they don’t have a ton of EE content), and I’ve also generally had extra room to use in my schedule.

I started my elective journey fairly early - a lot of students at Caltech take CS1, our introductory computer science class, in their first term here, and I did too. It was a nice introduction to object-oriented programming in Python, and Prof. Vanier frequently showed cat videos in class, which was an incentive to attend lectures (although the uploaded lecture slides were pretty good, so I can neither confirm nor deny that I missed a lecture here or there).

![A screen capture of a lecture slide that says: "You want to keep track of your friends' phone numbers. But you (naturally) have so many friends, this is a difficult job. How can the computer help?"](/images/2022/chase/513_20221222_000418_chrome.png "Classic CS1 lecture slide humor.")After CS1, I wanted to get my hands dirtier with programming, so I took CS2 with Prof. Blank the next term. In CS2, we worked in Java and implemented a number of data structures (linked lists, queues, deques, arraylists, etc.) from scratch. The class finished with more advanced concepts like hashmaps and [alpha-beta pruning](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning). The concepts were all introduced in the context of really neat projects – we wrote a basic text autocompleter, practiced [steganography](https://en.wikipedia.org/wiki/Steganography) by encoding hidden messages in images, and wrote a bot to play Othello, among other things. Our bot wasn’t the best, but it sure did play Othello.

![A picture of the IDE suggesting "wooliest," "wordiest," and "wobbliest" instead of the variable name "wordlist"](/images/2022/chase/514_20221222_000424_chrome.png "I only use the wobbliest of variables.")

CS2 especially was super interesting to me, so much so that I almost declared CS. I did declare EE as I had originally planned, and EE44 (circuits and systems with Prof. Hajimiri) the fall of my smore year reinforced that choice (although that’s a topic for another time). A lot of my classmates in CS2 went on to CS3 in the spring, and though the class sounded super interesting to me, core classes and COVID got in the way; I ended up waiting until the spring of my smore year to take it.

CS3 focused on familiarizing us with working in larger codebases – we wrote a physics engine and designed a game. Both CS2 and CS3 had individual labs and group projects (pairs in CS2 and groups of four in CS3), so I got a good bit of experience working with git repositories and collaborative coding. CS3 was taught in C, so I learned a fair bit about pointers, dereferencing, and good code practices. It was in CS3 that I really began to understand the usefulness of encapsulation and the importance of header files and documentation. I also definitely did not accidentally crash my computer by using up all the memory when I forgot to free something in a loop.

![A screen capture of bouncing stars of different shapes and colors](/images/2022/chase/515_20221222_000440_chrome.png "As we developed our physics engine, we tested it by making stars of various colors and shapes fall and bounce due to gravity.")

By the spring of my smore year, I knew for sure that I would be an EE major, which meant that none of CS1, 2, or 3 would count towards my graduation requirements. If I chose to pick up the CS minor, they would all count, of course. As it stands now, I don’t know if I’ll add the minor, but I’m still glad I took those classes. In particular, they all set me up for CS24, which was my original inspiration for writing this blog post. Seriously, that class was one of the highlights of my junior year fall term.

CS24 is a computer systems class. It’s also taught by Prof. Blank, and it’s known to be a fair bit of work – it’s one of the lowest-level ([low-level doesn't mean easy here!](https://en.wikipedia.org/wiki/Low-level_programming_language)) courses CS majors are required to take, and assemblers and virtual memory are tough things to understand. I was super hyped for this class, though, because as part of the EE option, I took a class called EE10ab that built the fundamentals of a computer up from the most basic digital logic. In EE10a, I wrote logic equations for an [arithmetic logic unit,](https://en.wikipedia.org/wiki/Arithmetic_logic_unit) data addressing unit, program memory access unit, and other modules, and then combined them to make my very own working central processing unit (CPU). It’s a ton of work, but it’s really cool to be able to say that I programmed and tested a CPU. In EE10b, I built on that CPU to make a microcontroller and wrote assembly code that actually ran on the microcontroller and let me play a game.

![A screen capture showing that I wrote over 5000 lines of code for my CPU](/images/2022/chase/516_20221222_000450_chrome.png "I wrote a lot of code for EE10b.")

Anyway, back to CS24 – it seemed to me like a really interesting way to meet the content from EE10 in the middle. We’d started at the lowest level in EE10 and worked our way up to a basic computer system that could run assembly. In CS24, we started with higher-level programming languages and worked our way down to the assembly level. CS24 is definitely one of the coolest classes I’ve taken here. We explored a variety of different ways computer architectures can be exploited for nefarious purposes, and we even did projects where we practiced those exploits.

CS1, CS2, CS3, and CS24 are all classes outside my option – I took them purely out of interest, and it’s been a good time! I have a more thorough understanding of computer architecture than if I’d only taken classes in my major, and I’ve picked up some really useful programming skills along the way, which ended up coming in handy in ME/CS/EE 133ab – but that’s a story for another time.